#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
This file is automatically generated by AION for AI0017_1 usecase.
File generation time: 2023-02-21 10:13:56
'''
#Standard Library modules
import json

#Third Party modules
import joblib
import pandas as pd 
import numpy as np 
from pathlib import Path
from pandas.io.json import json_normalize
from tensorflow.keras.models import load_model

#local modules
import utility as utils 

IOFiles = {
    "metaData": "modelMetaData.json",
    "log": "predict.log"
}
output_file = { }
class deploy():

    def __init__(self, base_config, log=None):
        self.targetPath = (Path('aion') / base_config['targetPath']).resolve()
        if log:
            self.logger = log
        else:
            log_file = self.targetPath / IOFiles['log']
            self.logger = logger(log_file, mode='a', logger_name=Path(__file__).parent.stem)
        try:
            self.initialize(base_config)
        except Exception as e:
            self.logger.error(e, exc_info=True)

    def initialize(self, base_config):
        targetPath = Path('aion') / base_config['targetPath']
        meta_data_file = targetPath / IOFiles['metaData']
        if meta_data_file.exists():
            meta_data = utils.read_json(meta_data_file)
        self.dateTimeFeature = meta_data['training']['dateTimeFeature']
        self.targetFeature = meta_data['training']['target_feature']

        normalization_file = meta_data['transformation']['Status']['Normalization_file']
        self.normalizer = joblib.load(normalization_file)
        self.lag_order = base_config['lag_order']
        self.noofforecasts = base_config['noofforecasts']
        run_id = str(meta_data['register']['runId'])
        model_path = str(targetPath/'runs'/str(meta_data['register']['runId'])/meta_data['register']['model']/'model')
        self.model = load_model(model_path)
        self.model_name = meta_data['register']['model']

    def predict(self, data=None):
        try:
            return self.__predict(data)
        except Exception as e:
            if self.logger:
                self.logger.error(e, exc_info=True)
            raise ValueError(json.dumps({'Status': 'Failure', 'Message': str(e)}))

    def __predict(self, data=None):
        jsonData = json.loads(data)

        dataFrame = json_normalize(jsonData)

        xtrain = dataFrame
        if len(dataFrame) == 0:
            raise ValueError('No data record found')

        df_l = len(dataFrame)
        pred_threshold = 0.1
        max_pred_by_user = round((df_l) * pred_threshold)
        # prediction for 24 steps or next 24 hours
        if self.noofforecasts == -1:
            self.noofforecasts = max_pred_by_user
        no_of_prediction = self.noofforecasts
        if (str(no_of_prediction) > str(max_pred_by_user)):
            no_of_prediction = max_pred_by_user
        noofforecasts = no_of_prediction

        # self.sfeatures.remove(self.datetimeFeature)
        features = self.targetFeature
        if len(features) == 1:
            xt = xtrain[features].values
        else:
            xt = xtrain[features].values
        xt = xt.astype('float32')
        xt = self.normalizer.transform(xt)
        pred_data = xt
        y_future = []
        self.lag_order = int(self.lag_order)
        for i in range(int(no_of_prediction)):
            pdata = pred_data[-self.lag_order:]
            if len(features) == 1:
                pdata = pdata.reshape((1, self.lag_order))
            else:
                pdata = pdata.reshape((1, self.lag_order, len(features)))

            if (len(features) > 1):
                pred = self.model.predict(pdata)
                predout = self.normalizer.inverse_transform(pred)
                y_future.append(predout)
                pred_data = np.append(pred_data, pred, axis=0)
            else:
                pred = self.model.predict(pdata)
                predout = self.normalizer.inverse_transform(pred)
                y_future.append(predout.flatten()[-1])
                pred_data = np.append(pred_data, pred)
        pred = pd.DataFrame(index=range(0, len(y_future)), columns=self.targetFeature)
        for i in range(0, len(y_future)):
            pred.iloc[i] = y_future[i]
        predictions = pred
        forecast_output = predictions.to_json(orient='records')
        return forecast_output        
        